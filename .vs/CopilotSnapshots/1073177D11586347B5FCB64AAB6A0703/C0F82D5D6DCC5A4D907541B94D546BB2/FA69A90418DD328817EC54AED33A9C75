// Data Context with Supabase Integration
import React, { useState, useContext, createContext, useMemo, useEffect } from 'react';
import { User, Produce, Contract, Transaction, Message } from '../types';
import { dbOperations, subscribeToMessages } from './supabaseHelpers';
import { toast } from 'react-toastify';

interface DataContextType {
  users: User[];
  produce: Produce[];
  contracts: Contract[];
  transactions: Transaction[];
  messages: Message[];
  updateUser: (updatedUser: User) => Promise<void>;
  updateContract: (updatedContract: Contract) => Promise<void>;
  addContract: (newContract: Contract) => Promise<void>;
  addProduce: (newProduce: Produce) => Promise<void>;
  addUser: (newUser: User) => Promise<User>;
  addTransaction: (newTransaction: Transaction) => Promise<void>;
  addMessage: (newMessage: Message) => Promise<void>;
  deleteUser: (userId: string) => Promise<void>;
  loading: boolean;
}

const DataContext = createContext<DataContextType | null>(null);

export const DataProvider = ({ children }: { children: React.ReactNode }) => {
  const [users, setUsers] = useState<User[]>([]);
  const [produce, setProduce] = useState<Produce[]>([]);
  const [contracts, setContracts] = useState<Contract[]>([]);
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [messages, setMessages] = useState<Message[]>([]);
  const [loading, setLoading] = useState(true);

  // Initial data fetch from Supabase
  useEffect(() => {
    const fetchAllData = async () => {
      try {
        setLoading(true);
        const [usersData, produceData, contractsData, transactionsData, messagesData] = await Promise.all([
          dbOperations.getUsers(),
          dbOperations.getProduce(),
          dbOperations.getContracts(),
          dbOperations.getTransactions(),
          dbOperations.getMessages(),
        ]);
        
        setUsers(usersData || []);
        setProduce(produceData || []);
        setContracts(contractsData || []);
        setTransactions(transactionsData || []);
        setMessages(messagesData || []);
      } catch (error: any) {
        console.error('Error fetching data:', error);
        toast.error('Failed to load data: ' + error.message);
      } finally {
        setLoading(false);
      }
    };

    fetchAllData();
  }, []);

  // Subscribe to realtime message updates
  useEffect(() => {
    const unsubscribe = subscribeToMessages((newMessage) => {
      setMessages(prev => {
        // Avoid duplicates
        if (prev.some(m => m.id === newMessage.id)) return prev;
        return [...prev, newMessage];
      });
    });

    return unsubscribe;
  }, []);

  const updateUser = async (updatedUser: User) => {
    try {
      const result = await dbOperations.updateUser(updatedUser);
      setUsers(prev => prev.map(u => u.id === updatedUser.id ? result : u));
    } catch (error: any) {
      toast.error('Failed to update user: ' + error.message);
      throw error;
    }
  };

  const updateContract = async (updatedContract: Contract) => {
    try {
      const result = await dbOperations.updateContract(updatedContract);
      setContracts(prev => prev.map(c => c.id === updatedContract.id ? result : c));
    } catch (error: any) {
      toast.error('Failed to update contract: ' + error.message);
      throw error;
    }
  };

  const addContract = async (newContract: Contract) => {
    try {
      const result = await dbOperations.createContract(newContract);
      setContracts(prev => [result, ...prev]);
    } catch (error: any) {
      toast.error('Failed to create contract: ' + error.message);
      throw error;
    }
  };

  const addProduce = async (newProduce: Produce) => {
    try {
      const result = await dbOperations.createProduce(newProduce);
      setProduce(prev => [result, ...prev]);
    } catch (error: any) {
      toast.error('Failed to add produce: ' + error.message);
      throw error;
    }
  };

  const addUser = async (newUser: User) => {
    try {
      const result = await dbOperations.createUser(newUser);
      setUsers(prev => [...prev, result]);
      return result;
    } catch (error: any) {
      toast.error('Failed to create user: ' + error.message);
      throw error;
    }
  };

  const addTransaction = async (newTransaction: Transaction) => {
    try {
      const result = await dbOperations.createTransaction(newTransaction);
      setTransactions(prev => [result, ...prev].sort((a,b) => 
        new Date(b.date).getTime() - new Date(a.date).getTime()
      ));
    } catch (error: any) {
      toast.error('Failed to add transaction: ' + error.message);
      throw error;
    }
  };

  const addMessage = async (newMessage: Message) => {
    try {
      const result = await dbOperations.createMessage(newMessage);
      setMessages(prev => {
        if (prev.some(m => m.id === result.id)) return prev;
        return [...prev, result];
      });
    } catch (error: any) {
      toast.error('Failed to send message: ' + error.message);
      throw error;
    }
  };

  const deleteUser = async (userId: string) => {
    try {
      await dbOperations.deleteUser(userId);
      setUsers(prev => prev.filter(u => u.id !== userId));
    } catch (error: any) {
      toast.error('Failed to delete user: ' + error.message);
      throw error;
    }
  };

  const value = useMemo(() => ({
    users, produce, contracts, transactions, messages,
    updateUser, updateContract, addContract, addProduce, addUser, addTransaction, addMessage, deleteUser,
    loading
  }), [users, produce, contracts, transactions, messages, loading]);

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
};

export const useData = () => {
  const context = useContext(DataContext);
  if (!context) {
    throw new Error('useData must be used within a DataProvider');
  }
  return context;
};
