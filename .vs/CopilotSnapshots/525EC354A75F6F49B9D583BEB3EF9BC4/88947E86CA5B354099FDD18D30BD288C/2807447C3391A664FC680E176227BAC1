// Auth Context with Supabase Integration (enhanced)
import React, { useState, useContext, createContext, useMemo, useEffect } from 'react';
import { User, UserRole } from '../types';
import { sendOTP, verifyOTP, signOut, initAuthSession, subscribeToAuthChanges } from '../supabaseHelpers';
import { useData } from './DataContext';
import { toast } from 'react-toastify';
import { supabase } from '../supabaseClient';

interface MinimalProfileData {
  name: string;
  email: string;
  role: UserRole;
}

interface AuthContextType {
  user: User | null;
  loadingAuth: boolean;
  authError: string | null;
  // OTP based
  login: (email: string, intendedRole?: UserRole) => Promise<boolean>; // send OTP
  verifyCode: (email: string, code: string) => Promise<{ success: boolean }>;

  // Password based
  loginWithPassword: (email: string, password: string) => Promise<{ success: boolean }>;
  registerWithPassword: (profileData: MinimalProfileData, password: string) => Promise<{ success: boolean }>;

  // Utilities
  logout: () => Promise<void>;
  setIntendedRole: (role: UserRole | null) => void;
}

const AuthContext = createContext<AuthContextType | null>(null);

// --- Helpers --- //
const normalizeEmail = (email: string) => email.trim().toLowerCase();
const passwordPolicyOk = (pw: string) => /^(?=.*[A-Za-z])(?=.*\d).{6,}$/.test(pw); // at least 6 chars, letter + number

const mapSupabaseError = (message: string) => {
  if (/Invalid login credentials/i.test(message)) return 'Incorrect email or password';
  if (/Email not confirmed/i.test(message)) return 'Please confirm your email before logging in';
  if (/Password should be/i.test(message)) return 'Password too weak';
  if (/user already exists/i.test(message)) return 'An account with this email already exists';
  return message;
};

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loadingAuth, setLoadingAuth] = useState(true);
  const [authError, setAuthError] = useState<string | null>(null);
  const [intendedRole, setIntendedRole] = useState<UserRole | null>(null);
  const { users, addUser } = useData();

  // Initialize auth session on mount
  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const profile = await initAuthSession();
        if (mounted && profile) setUser(profile);
      } catch (error: any) {
        console.error('Auth initialization error:', error);
      } finally {
        if (mounted) setLoadingAuth(false);
      }
    })();
    return () => { mounted = false; };
  }, []);

  // Subscribe to auth changes
  useEffect(() => {
    const unsubscribe = subscribeToAuthChanges(({ session, profile }) => {
      if (profile) {
        setUser(profile);
      } else if (!session) {
        setUser(null);
      }
    });
    return unsubscribe;
  }, []);

  // Keep local user updated with data context
  useEffect(() => {
    if (user) {
      const updated = users.find(u => u.id === user.id);
      if (updated && JSON.stringify(updated) !== JSON.stringify(user)) setUser(updated);
    }
  }, [users, user]);

  // Ensure profile exists (for OTP or first password login)
  const ensureProfile = async (email: string) => {
    const authUser = (await supabase.auth.getUser()).data.user;
    if (!authUser) return null;
    const existing = users.find(u => u.id === authUser.id);
    if (existing) return existing;
    const role = intendedRole || UserRole.VENDOR; // fallback vendor
    const newUser: User = {
      id: authUser.id,
      name: email.split('@')[0],
      email: normalizeEmail(email),
      role,
      location: '',
      farmSize: '',
      businessName: '',
      rating: 0,
      reviews: 0,
      avatarUrl: '',
      walletBalance: 0,
    } as User;
    const created = await addUser(newUser);
    setUser(created);
    return created;
  };

  // OTP: send code
  const login = async (email: string, role?: UserRole): Promise<boolean> => {
    setAuthError(null);
    try {
      const normalized = normalizeEmail(email);
      if (role) setIntendedRole(role);
      await sendOTP(normalized);
      toast.info('Check your email for the login code');
      return true;
    } catch (error: any) {
      const msg = mapSupabaseError(error.message || 'Failed to send code');
      setAuthError(msg);
      toast.error(msg);
      return false;
    }
  };

  // OTP: verify
  const verifyCode = async (email: string, code: string): Promise<{ success: boolean }> => {
    setAuthError(null);
    try {
      const normalized = normalizeEmail(email);
      const { profile } = await verifyOTP(normalized, code);
      if (profile) {
        setUser(profile);
        return { success: true };
      }
      // create profile automatically
      await ensureProfile(normalized);
      toast.success('Welcome! Profile initialized.');
      return { success: true };
    } catch (error: any) {
      const msg = mapSupabaseError(error.message || 'Verification failed');
      setAuthError(msg);
      toast.error(msg);
      return { success: false };
    }
  };

  // Password login
  const loginWithPassword = async (email: string, password: string): Promise<{ success: boolean }> => {
    setAuthError(null);
    try {
      const normalized = normalizeEmail(email);
      const { data, error } = await supabase.auth.signInWithPassword({ email: normalized, password });
      if (error) throw error;
      if (!data.session) {
        setAuthError('Login failed');
        toast.error('Login failed');
        return { success: false };
      }
      const profile = await initAuthSession();
      if (profile) {
        setUser(profile);
        return { success: true };
      }
      await ensureProfile(normalized);
      toast.success('Profile created');
      return { success: true };
    } catch (error: any) {
      const msg = mapSupabaseError(error.message || 'Password login failed');
      setAuthError(msg);
      toast.error(msg);
      return { success: false };
    }
  };

  // Registration
  const registerWithPassword = async (profileData: MinimalProfileData, password: string): Promise<{ success: boolean }> => {
    setAuthError(null);
    try {
      const email = normalizeEmail(profileData.email);
      if (!passwordPolicyOk(password)) {
        const msg = 'Password must be 6+ chars and include a number';
        setAuthError(msg); toast.error(msg); return { success: false };
      }
      setIntendedRole(profileData.role);
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: { emailRedirectTo: window.location.origin + '/#/login' }
      });
      if (error) throw error;

      // If session exists immediately, create profile row now; otherwise wait until login
      const { data: sessionData } = await supabase.auth.getSession();
      if (sessionData.session) {
        await ensureProfile(email);
        toast.success('Account created');
      } else {
        toast.info('Check your email to confirm your account');
      }
      return { success: true };
    } catch (error: any) {
      const msg = mapSupabaseError(error.message || 'Registration failed');
      setAuthError(msg);
      toast.error(msg);
      return { success: false };
    }
  };

  const logout = async () => {
    try {
      await signOut();
      setUser(null);
      setIntendedRole(null);
      toast.info('Logged out');
    } catch (error: any) {
      toast.error('Logout failed: ' + error.message);
    }
  };

  const value = useMemo(() => ({
    user,
    loadingAuth,
    authError,
    login,
    verifyCode,
    loginWithPassword,
    registerWithPassword,
    logout,
    setIntendedRole,
  }), [user, loadingAuth, authError]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within an AuthProvider');
  return context;
};
